<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Smart Construction Helmet</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            color: white;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.85);
            padding: 25px;
            border-radius: 15px;
            max-width: 350px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2);
        }

        #info h2 {
            font-size: 1.8em;
            margin-top: 0;
            color: #f39c12;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .control-button {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            color: white;
            border: none;
            padding: 12px 18px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(243, 156, 18, 0.4);
        }

        #status {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.85);
            padding: 25px;
            border-radius: 15px;
            max-width: 300px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2);
        }

        #status h3 {
            color: #f39c12;
            margin-top: 0;
            margin-bottom: 15px;
        }

        .status-item {
            margin: 15px 0;
            padding: 12px;
            border-radius: 8px;
            font-size: 1em;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: bold;
        }

        .status-disconnected {
            background: rgba(231, 76, 60, 0.3);
            border-left: 4px solid #e74c3c;
        }

        .status-ready {
            background: rgba(243, 156, 18, 0.3);
            border-left: 4px solid #f39c12;
        }

        .status-connected {
            background: rgba(39, 174, 96, 0.3);
            border-left: 4px solid #27ae60;
        }

        .led-indicator {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            display: inline-block;
            animation: pulse 2s infinite;
        }

        .led-red { background: #e74c3c; box-shadow: 0 0 10px #e74c3c; }
        .led-yellow { background: #f39c12; box-shadow: 0 0 10px #f39c12; }
        .led-green { background: #27ae60; box-shadow: 0 0 10px #27ae60; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .power-button {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 15px 25px;
            margin-top: 10px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1em;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4);
        }

        .power-button:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(231, 76, 60, 0.6);
        }

        .power-button.on {
            background: #27ae60;
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.4);
        }

        .power-button.on:hover {
            box-shadow: 0 8px 20px rgba(39, 174, 96, 0.6);
        }

        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
        }

        .spinner {
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid #f39c12;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">
            <div class="spinner"></div>
            <div>Loading Realistic Construction Helmet...</div>
        </div>

        <div id="info">
            <h2>üèóÔ∏è Smart Construction Helmet</h2>
            <p><strong>Realistic Hard Hat Design:</strong></p>
            <ul>
                <li>üìπ <strong>Front Camera</strong> - ESP32-CAM integrated</li>
                <li>üö¶ <strong>RGB Status LED</strong> - Connection indicator</li>
                <li>üõ∞Ô∏è <strong>GPS Module</strong> - Location tracking</li>
                <li>üîã <strong>External Battery</strong> - Back-mounted power</li>
                <li>üîò <strong>Power Button</strong> - Side-mounted control</li>
                <li>‚ö° <strong>Suspension System</strong> - Professional fit</li>
            </ul>
            <p><strong>LED Status:</strong></p>
            <div style="font-size: 0.9em; margin-top: 10px;">
                <div>üî¥ Red: Disconnected</div>
                <div>üü° Yellow: Ready to Connect</div>
                <div>üü¢ Green: Connected & Recording</div>
            </div>
        </div>

        <div id="controls">
            <h3>üéÆ Controls</h3>
            <button class="control-button" onclick="toggleRotation()">‚è∏Ô∏è Pause/Resume</button>
            <button class="control-button" onclick="resetView()">üîÑ Reset View</button>
            <button class="control-button" onclick="toggleWireframe()">üìê Wireframe</button>
            <br>
            <button class="power-button" id="powerBtn" onclick="togglePower()">üîå POWER OFF</button>
        </div>

        <div id="status">
            <h3>üìä Helmet Status</h3>
            <div class="status-item status-disconnected" id="statusDisplay">
                <span class="led-indicator led-red"></span>
                <span>System Offline</span>
            </div>
            <div style="margin-top: 15px; font-size: 0.9em;">
                <div><strong>üõ∞Ô∏è GPS:</strong> <span id="gpsStatus">No Signal</span></div>
                <div><strong>üìπ Camera:</strong> <span id="cameraStatus">Standby</span></div>
                <div><strong>üîã Battery:</strong> <span id="batteryStatus">85%</span></div>
                <div><strong>üì° WiFi:</strong> <span id="wifiStatus">Disconnected</span></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, helmet;
        let cameraModule, ledLight, gpsModule, batteryPack, powerButton;
        let isRotating = true;
        let isWireframe = false;
        let isPoweredOn = false;
        let statusMode = 0;

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(3, 2, 4);
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.physicallyCorrectLights = true;
            document.getElementById('container').appendChild(renderer.domElement);

            // Enhanced lighting for realistic appearance
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const pointLight1 = new THREE.PointLight(0xffffff, 0.4);
            pointLight1.position.set(-5, 5, 5);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xf39c12, 0.2);
            pointLight2.position.set(5, -5, -5);
            scene.add(pointLight2);

            // Ground plane
            createGround();
            
            // Create realistic helmet
            createRealisticHelmet();
            
            // Add smart components
            createSmartComponents();

            // Hide loading screen
            document.getElementById('loading').style.display = 'none';

            // Start animation
            animate();
        }

        function createGround() {
            const groundGeometry = new THREE.CircleGeometry(5, 32);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x34495e,
                transparent: true,
                opacity: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -1;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function createRealisticHelmet() {
            helmet = new THREE.Group();

            // Main helmet body - realistic construction helmet shape
            const helmetBody = createHelmetBody();
            helmet.add(helmetBody);

            // Helmet brim - proper construction helmet brim
            const brim = createHelmetBrim();
            helmet.add(brim);

            // Suspension system inside
            const suspension = createSuspensionSystem();
            helmet.add(suspension);

            // Adjustment knob at back
            const adjustmentKnob = createAdjustmentKnob();
            helmet.add(adjustmentKnob);

            // Chin strap attachment points
            const strapAttachments = createStrapAttachments();
            helmet.add(strapAttachments);

            scene.add(helmet);
        }

        function createHelmetBody() {
            // Create the main dome shape using a custom geometry
            const helmetGroup = new THREE.Group();

            // Main dome - flatter on top like real hard hats
            const domeGeometry = new THREE.SphereGeometry(1.1, 32, 16, 0, Math.PI * 2, 0, Math.PI * 0.7);
            const helmetMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xFFEB3B, // Bright yellow like construction helmets
                metalness: 0.1,
                roughness: 0.3,
                clearcoat: 0.8,
                clearcoatRoughness: 0.2,
                transparent: false,
                side: THREE.FrontSide
            });
            
            const dome = new THREE.Mesh(domeGeometry, helmetMaterial);
            dome.position.y = 0.1;
            dome.castShadow = true;
            dome.receiveShadow = true;
            helmetGroup.add(dome);

            // Flatten the top slightly
            const topCapGeometry = new THREE.CylinderGeometry(0.8, 0.9, 0.2, 32);
            const topCap = new THREE.Mesh(topCapGeometry, helmetMaterial);
            topCap.position.y = 0.7;
            helmetGroup.add(topCap);

            // Add subtle ridges for strength (like real helmets)
            for (let i = 0; i < 4; i++) {
                const ridgeGeometry = new THREE.BoxGeometry(0.02, 0.02, 1.8);
                const ridgeMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0xF57F17, // Slightly darker yellow
                    metalness: 0.1,
                    roughness: 0.4
                });
                const ridge = new THREE.Mesh(ridgeGeometry, ridgeMaterial);
                const angle = (i / 4) * Math.PI * 2;
                ridge.position.x = Math.cos(angle) * 0.9;
                ridge.position.z = Math.sin(angle) * 0.9;
                ridge.position.y = 0.2;
                ridge.rotation.y = angle;
                ridge.rotation.x = -Math.PI / 6;
                helmetGroup.add(ridge);
            }

            return helmetGroup;
        }

        function createHelmetBrim() {
            // Realistic brim shape
            const brimShape = new THREE.Shape();
            
            // Outer edge
            const outerRadius = 1.4;
            const innerRadius = 1.05;
            
            // Create brim outline
            for (let i = 0; i <= 32; i++) {
                const angle = (i / 32) * Math.PI * 2;
                const x = Math.cos(angle) * outerRadius;
                const y = Math.sin(angle) * outerRadius;
                if (i === 0) {
                    brimShape.moveTo(x, y);
                } else {
                    brimShape.lineTo(x, y);
                }
            }
            
            // Inner hole
            const hole = new THREE.Path();
            for (let i = 0; i <= 32; i++) {
                const angle = (i / 32) * Math.PI * 2;
                const x = Math.cos(angle) * innerRadius;
                const y = Math.sin(angle) * innerRadius;
                if (i === 0) {
                    hole.moveTo(x, y);
                } else {
                    hole.lineTo(x, y);
                }
            }
            brimShape.holes.push(hole);

            const extrudeSettings = {
                steps: 1,
                depth: 0.05,
                bevelEnabled: true,
                bevelThickness: 0.01,
                bevelSize: 0.01,
                bevelSegments: 2
            };

            const brimGeometry = new THREE.ExtrudeGeometry(brimShape, extrudeSettings);
            const brimMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xFFEB3B,
                metalness: 0.1,
                roughness: 0.4,
                clearcoat: 0.6,
                clearcoatRoughness: 0.3
            });

            const brim = new THREE.Mesh(brimGeometry, brimMaterial);
            brim.rotation.x = -Math.PI / 2;
            brim.position.y = -0.4;
            brim.castShadow = true;
            brim.receiveShadow = true;

            return brim;
        }

        function createSuspensionSystem() {
            const suspensionGroup = new THREE.Group();
            
            // Inner suspension band
            const bandGeometry = new THREE.TorusGeometry(0.8, 0.02, 8, 32);
            const bandMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2c3e50,
                metalness: 0.1,
                roughness: 0.8
            });
            const band = new THREE.Mesh(bandGeometry, bandMaterial);
            band.position.y = -0.2;
            suspensionGroup.add(band);

            // Suspension straps
            for (let i = 0; i < 6; i++) {
                const strapGeometry = new THREE.BoxGeometry(0.03, 0.3, 0.01);
                const strapMaterial = new THREE.MeshStandardMaterial({ color: 0x34495e });
                const strap = new THREE.Mesh(strapGeometry, strapMaterial);
                const angle = (i / 6) * Math.PI * 2;
                strap.position.x = Math.cos(angle) * 0.8;
                strap.position.z = Math.sin(angle) * 0.8;
                strap.position.y = 0.1;
                strap.rotation.y = angle;
                suspensionGroup.add(strap);
            }

            return suspensionGroup;
        }

        function createAdjustmentKnob() {
            const knobGroup = new THREE.Group();
            
            // Main adjustment wheel
            const wheelGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.04, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2c3e50,
                metalness: 0.2,
                roughness: 0.6
            });
            const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel.rotation.x = Math.PI / 2;
            wheel.position.set(0, -0.2, -1.0);
            knobGroup.add(wheel);

            // Adjustment mechanism
            const mechGeometry = new THREE.BoxGeometry(0.15, 0.06, 0.08);
            const mechMaterial = new THREE.MeshStandardMaterial({ color: 0x34495e });
            const mechanism = new THREE.Mesh(mechGeometry, mechMaterial);
            mechanism.position.set(0, -0.2, -0.95);
            knobGroup.add(mechanism);

            return knobGroup;
        }

        function createStrapAttachments() {
            const attachmentGroup = new THREE.Group();
            
            // Left and right strap attachment points
            for (let side of [-1, 1]) {
                const attachGeometry = new THREE.BoxGeometry(0.04, 0.06, 0.02);
                const attachMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
                const attachment = new THREE.Mesh(attachGeometry, attachMaterial);
                attachment.position.set(side * 1.0, -0.3, 0.3);
                attachmentGroup.add(attachment);

                // Strap clips
                const clipGeometry = new THREE.RingGeometry(0.02, 0.03, 8);
                const clipMaterial = new THREE.MeshStandardMaterial({ color: 0x34495e });
                const clip = new THREE.Mesh(clipGeometry, clipMaterial);
                clip.position.set(side * 1.0, -0.35, 0.3);
                clip.rotation.x = Math.PI / 2;
                attachmentGroup.add(clip);
            }

            return attachmentGroup;
        }

        function createSmartComponents() {
            // Front-mounted camera module (wider to accommodate LED)
            const cameraHousingGeometry = new THREE.BoxGeometry(0.35, 0.15, 0.12);
            const cameraHousingMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2c3e50,
                metalness: 0.2,
                roughness: 0.6
            });
            cameraModule = new THREE.Mesh(cameraHousingGeometry, cameraHousingMaterial);
            cameraModule.position.set(0, 0.1, 1.05);
            cameraModule.castShadow = true;
            helmet.add(cameraModule);

            // Camera lens (positioned to the left of center)
            const lensGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.05, 16);
            const lensMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                metalness: 0.9,
                roughness: 0.1
            });
            const lens = new THREE.Mesh(lensGeometry, lensMaterial);
            lens.position.set(-0.08, 0, 0.08); // Moved to left side of housing
            lens.rotation.x = Math.PI / 2;
            cameraModule.add(lens);

            // RGB LED status indicator (right next to camera)
            const ledGeometry = new THREE.SphereGeometry(0.035, 16, 16);
            const ledMaterial = new THREE.MeshPhongMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.5
            });
            ledLight = new THREE.Mesh(ledGeometry, ledMaterial);
            ledLight.position.set(0.08, 0, 0.08); // Right next to the camera lens
            cameraModule.add(ledLight);

            // LED housing/bezel
            const ledHousingGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.02, 16);
            const ledHousingMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x34495e,
                metalness: 0.1,
                roughness: 0.7
            });
            const ledHousing = new THREE.Mesh(ledHousingGeometry, ledHousingMaterial);
            ledHousing.position.set(0.08, 0, 0.07);
            ledHousing.rotation.x = Math.PI / 2;
            cameraModule.add(ledHousing);

            // GPS module on top
            const gpsGeometry = new THREE.BoxGeometry(0.2, 0.04, 0.2);
            const gpsMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3498db,
                metalness: 0.1,
                roughness: 0.5
            });
            gpsModule = new THREE.Mesh(gpsGeometry, gpsMaterial);
            gpsModule.position.set(0, 0.85, 0);
            helmet.add(gpsModule);

            // GPS antenna
            const antennaGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.2, 8);
            const antennaMaterial = new THREE.MeshStandardMaterial({ color: 0x34495e });
            const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
            antenna.position.set(0, 0.95, 0);
            helmet.add(antenna);

            // External battery pack (realistic placement)
            const batteryGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.15);
            const batteryMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2c3e50,
                metalness: 0.1,
                roughness: 0.7
            });
            batteryPack = new THREE.Mesh(batteryGeometry, batteryMaterial);
            batteryPack.position.set(0, -0.1, -1.1);
            batteryPack.castShadow = true;
            helmet.add(batteryPack);

            // Battery status indicator
            const batteryLEDGeometry = new THREE.BoxGeometry(0.4, 0.05, 0.02);
            const batteryLEDMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x27ae60,
                emissive: 0x27ae60,
                emissiveIntensity: 0.3
            });
            const batteryLED = new THREE.Mesh(batteryLEDGeometry, batteryLEDMaterial);
            batteryLED.position.set(0, 0.05, 0.08);
            batteryPack.add(batteryLED);

            // Power button (prominently placed on the front-right side)
            const buttonHousingGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.06, 16);
            const buttonHousingMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2c3e50,
                metalness: 0.2,
                roughness: 0.6
            });
            const buttonHousing = new THREE.Mesh(buttonHousingGeometry, buttonHousingMaterial);
            buttonHousing.position.set(0.7, 0.2, 0.8);
            buttonHousing.rotation.z = -Math.PI / 6; // Slight angle for easy access
            buttonHousing.castShadow = true;
            helmet.add(buttonHousing);

            const buttonGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.04, 16);
            const buttonMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xe74c3c,
                metalness: 0.1,
                roughness: 0.4
            });
            powerButton = new THREE.Mesh(buttonGeometry, buttonMaterial);
            powerButton.position.set(0, 0, 0.02);
            buttonHousing.add(powerButton);

            // Power button label/icon
            const buttonLabelGeometry = new THREE.RingGeometry(0.03, 0.04, 16);
            const buttonLabelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide
            });
            const buttonLabel = new THREE.Mesh(buttonLabelGeometry, buttonLabelMaterial);
            buttonLabel.position.set(0, 0, 0.025);
            powerButton.add(buttonLabel);

            // ON/OFF text indicator
            const textGeometry = new THREE.PlaneGeometry(0.15, 0.03);
            const textMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            const textLabel = new THREE.Mesh(textGeometry, textMaterial);
            textLabel.position.set(0, -0.06, 0.04);
            buttonHousing.add(textLabel);

            // Add labels to camera module
            const cameraLabelGeometry = new THREE.PlaneGeometry(0.25, 0.04);
            const cameraLabelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });
            const cameraLabel = new THREE.Mesh(cameraLabelGeometry, cameraLabelMaterial);
            cameraLabel.position.set(0, -0.08, 0.08);
            cameraModule.add(cameraLabel);

            // Connecting wires (simplified but realistic)
            createWiring();
        }

        function createWiring() {
            const wireMaterial = new THREE.MeshStandardMaterial({ color: 0x34495e });
            
            // Main power cable from button to battery (more visible routing)
            const powerCableGeometry = new THREE.CylinderGeometry(0.012, 0.012, 1.5, 8);
            const powerCable = new THREE.Mesh(powerCableGeometry, wireMaterial);
            powerCable.position.set(0.3, -0.1, -0.2);
            powerCable.rotation.z = Math.PI / 4;
            helmet.add(powerCable);

            // Camera data cable
            const dataCableGeometry = new THREE.CylinderGeometry(0.008, 0.008, 1.0, 8);
            const dataCable = new THREE.Mesh(dataCableGeometry, wireMaterial);
            dataCable.position.set(0.2, -0.2, 0.2);
            dataCable.rotation.z = Math.PI / 3;
            helmet.add(dataCable);

            // GPS antenna cable
            const gpsCableGeometry = new THREE.CylinderGeometry(0.006, 0.006, 0.8, 8);
            const gpsCable = new THREE.Mesh(gpsCableGeometry, wireMaterial);
            gpsCable.position.set(-0.1, 0.2, -0.3);
            gpsCable.rotation.x = Math.PI / 4;
            helmet.add(gpsCable);

            // Cable management clips
            for (let i = 0; i < 3; i++) {
                const clipGeometry = new THREE.BoxGeometry(0.02, 0.01, 0.03);
                const clipMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
                const clip = new THREE.Mesh(clipGeometry, clipMaterial);
                clip.position.set(0.2 + i * 0.1, -0.3, 0.5 - i * 0.2);
                helmet.add(clip);
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isRotating) {
                helmet.rotation.y += 0.008;
            }

            // Animate LED based on power status
            if (isPoweredOn) {
                const time = Date.now() * 0.003;
                ledLight.material.emissiveIntensity = Math.sin(time) * 0.3 + 0.7;
            } else {
                ledLight.material.emissiveIntensity = 0.2;
            }

            renderer.render(scene, camera);
        }

        function togglePower() {
            isPoweredOn = !isPoweredOn;
            const powerBtn = document.getElementById('powerBtn');
            const gpsStatus = document.getElementById('gpsStatus');
            const cameraStatus = document.getElementById('cameraStatus');
            const wifiStatus = document.getElementById('wifiStatus');
            const batteryStatus = document.getElementById('batteryStatus');

            if (isPoweredOn) {
                powerBtn.textContent = 'üîå SYSTEM ON';
                powerBtn.classList.add('on');
                
                // Animate the physical button being pressed
                powerButton.material.color.setHex(0x27ae60);
                powerButton.position.z = -0.01; // Button pressed in
                
                // Boot sequence
                setTimeout(() => {
                    updateStatus(1); // Ready (Yellow)
                    gpsStatus.textContent = 'Acquiring Signal...';
                    cameraStatus.textContent = 'Camera Initializing...';
                    wifiStatus.textContent = 'Scanning Networks...';
                }, 500);
                
                setTimeout(() => {
                    updateStatus(2); // Connected (Green)
                    gpsStatus.textContent = 'GPS Locked (3D Fix)';
                    cameraStatus.textContent = 'Recording Active';
                    wifiStatus.textContent = 'Connected to Site-WiFi';
                    batteryStatus.textContent = '80% (Active Mode)';
                }, 2500);
                
            } else {
                powerBtn.textContent = 'üîå SYSTEM OFF';
                powerBtn.classList.remove('on');
                
                // Reset button appearance
                powerButton.material.color.setHex(0xe74c3c);
                powerButton.position.z = 0.02; // Button released
                
                updateStatus(0); // Disconnected (Red)
                gpsStatus.textContent = 'No Signal';
                cameraStatus.textContent = 'Standby';
                wifiStatus.textContent = 'Disconnected';
                batteryStatus.textContent = '85% (Idle)';
            }
        }

        function updateStatus(mode) {
            statusMode = mode;
            const statusDisplay = document.getElementById('statusDisplay');
            
            switch(mode) {
                case 0: // Disconnected
                    ledLight.material.color.setHex(0xe74c3c);
                    ledLight.material.emissive.setHex(0xe74c3c);
                    statusDisplay.className = 'status-item status-disconnected';
                    statusDisplay.innerHTML = '<span class="led-indicator led-red"></span><span>System Offline</span>';
                    break;
                case 1: // Ready
                    ledLight.material.color.setHex(0xf39c12);
                    ledLight.material.emissive.setHex(0xf39c12);
                    statusDisplay.className = 'status-item status-ready';
                    statusDisplay.innerHTML = '<span class="led-indicator led-yellow"></span><span>Ready to Connect</span>';
                    break;
                case 2: // Connected
                    ledLight.material.color.setHex(0x27ae60);
                    ledLight.material.emissive.setHex(0x27ae60);
                    statusDisplay.className = 'status-item status-connected';
                    statusDisplay.innerHTML = '<span class="led-indicator led-green"></span><span>Connected & Recording</span>';
                    break;
            }
        }

        function toggleRotation() {
            isRotating = !isRotating;
        }

        function resetView() {
            camera.position.set(3, 2, 4);
            camera.lookAt(0, 0, 0);
            helmet.rotation.set(0, 0, 0);
        }

        function toggleWireframe() {
            isWireframe = !isWireframe;
            helmet.traverse((child) => {
                if (child.isMesh && child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.wireframe = isWireframe);
                    } else {
                        child.material.wireframe = isWireframe;
                    }
                }
            });
        }

        // Mouse controls
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;

        document.addEventListener('mousemove', (event) => {
            if (isMouseDown) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                helmet.rotation.y += deltaX * 0.01;
                helmet.rotation.x += deltaY * 0.01;
                
                // Clamp vertical rotation
                helmet.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, helmet.rotation.x));
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        });

        document.addEventListener('mousedown', (event) => {
            // Don't rotate if clicking on UI elements
            if (event.target.closest('#info') || event.target.closest('#controls') || event.target.closest('#status')) {
                return;
            }
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // Touch controls for mobile
        let touchStartX = 0, touchStartY = 0;

        document.addEventListener('touchstart', (event) => {
            if (event.target.closest('#info') || event.target.closest('#controls') || event.target.closest('#status')) {
                return;
            }
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        });

        document.addEventListener('touchmove', (event) => {
            event.preventDefault();
            const deltaX = event.touches[0].clientX - touchStartX;
            const deltaY = event.touches[0].clientY - touchStartY;
            
            helmet.rotation.y += deltaX * 0.005;
            helmet.rotation.x += deltaY * 0.005;
            
            // Clamp vertical rotation
            helmet.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, helmet.rotation.x));
            
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        });

        // Zoom with mouse wheel
        document.addEventListener('wheel', (event) => {
            camera.position.z += event.deltaY * 0.01;
            camera.position.z = Math.max(2, Math.min(8, camera.position.z));
        });

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize the scene
        init();
    </script>
</body>
</html>